import { Resend } from 'resend';
import { corsHeaders, addCorsHeaders } from '../util/cors.js';

// Initialize Resend with API key from environment variables
const resend = new Resend(process.env.RESEND_API_KEY);

// Rate limiting storage - in-memory Map
// Key: IP address, Value: Array of submission timestamps
const rateLimitMap = new Map();

// Security logging and monitoring
const suspiciousActivityMap = new Map();

// Enhanced logging for security monitoring
function logSecurityEvent(event, data, clientIP) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    clientIP,
    userAgent: data.userAgent || 'unknown',
    ...data
  };
  
  // Log to console (in production, use proper logging service)
  console.log('SECURITY_EVENT:', JSON.stringify(logEntry));
  
  // Track suspicious patterns
  if (event === 'spam_detected' || event === 'rate_limited' || event === 'suspicious_behavior') {
    trackSuspiciousActivity(clientIP, event);
  }
}

function trackSuspiciousActivity(ip, event) {
  const key = `suspicious_${ip}`;
  const count = suspiciousActivityMap.get(key) || 0;
  suspiciousActivityMap.set(key, count + 1);
  
  // If too many suspicious activities, consider blocking IP
  if (count >= 5) {
    console.warn(`IP ${ip} flagged for suspicious activity (${count + 1} events)`);
    logSecurityEvent('ip_flagged', { ip, eventCount: count + 1 }, ip);
  }
}

// Clean up suspicious activity tracking
function cleanupSuspiciousActivity() {
  const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
  
  for (const [key, timestamp] of suspiciousActivityMap.entries()) {
    if (timestamp < oneDayAgo) {
      suspiciousActivityMap.delete(key);
    }
  }
}

// Clean up old rate limit entries (older than 1 hour)
function cleanupRateLimit() {
  const oneHourAgo = Date.now() - (60 * 60 * 1000);
  
  for (const [ip, timestamps] of rateLimitMap.entries()) {
    const recentTimestamps = timestamps.filter(timestamp => timestamp > oneHourAgo);
    
    if (recentTimestamps.length === 0) {
      rateLimitMap.delete(ip);
    } else {
      rateLimitMap.set(ip, recentTimestamps);
    }
  }
}

// Enhanced rate limiting with progressive delays
function checkEnhancedRateLimit(ip) {
  cleanupRateLimit();
  
  const now = Date.now();
  const timestamps = rateLimitMap.get(ip) || [];
  const recentTimestamps = timestamps.filter(timestamp => now - timestamp < 3600000); // 1 hour
  
  // Progressive rate limiting
  if (recentTimestamps.length >= 10) {
    return { 
      allowed: false, 
      reason: 'Too many requests', 
      retryAfter: 3600,
      level: 'blocked'
    };
  } else if (recentTimestamps.length >= 5) {
    return { 
      allowed: false, 
      reason: 'Rate limited', 
      retryAfter: 300,
      level: 'rate_limited'
    };
  } else if (recentTimestamps.length >= 3) {
    return { 
      allowed: false, 
      reason: 'Please slow down', 
      retryAfter: 60,
      level: 'slow_down'
    };
  }
  
  // Add current timestamp
  recentTimestamps.push(now);
  rateLimitMap.set(ip, recentTimestamps);
  
  return { 
    allowed: true, 
    level: 'normal',
    remainingRequests: Math.max(0, 10 - recentTimestamps.length)
  };
}

// Backward compatibility wrapper
function checkRateLimit(ip) {
  const result = checkEnhancedRateLimit(ip);
  return result.allowed;
}

// Sanitize input to prevent XSS attacks
function sanitizeInput(input) {
  if (typeof input !== 'string') return '';
  
  return input
    .trim()
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

// Comprehensive spam domains list for blocking disposable emails
const SPAM_DOMAINS = new Set([
  '10minutemail.com', 'guerrillamail.com', 'mailinator.com', 'tempmail.org',
  'throwaway.email', 'temp-mail.org', 'maildrop.cc', 'sharklasers.com',
  'guerrillamailblock.com', 'pokemail.net', 'spam4.me', 'bccto.me',
  'chacuo.net', 'dispostable.com', 'mailnesia.com', 'mailcatch.com',
  'mailmetrash.com', 'trashmail.net', 'trashmail.com', 'spamgourmet.com',
  'spamgourmet.org', 'spamgourmet.net', 'spam.la', 'binkmail.com',
  'bobmail.info', 'chammy.info', 'devnullmail.com', 'letthemeatspam.com',
  'mailin8r.com', 'mailinator2.com', 'notmailinator.com', 'reallymymail.com',
  'sogetthis.com', 'spamhereplease.com', 'superrito.com', 'thisisnotmyrealemail.com',
  'tradermail.info', 'veryrealemail.com', 'wegwerfmail.de', 'wegwerfmail.net',
  'wegwerfmail.org', 'wegwerpmailadres.nl', 'wetrainbayarea.com', 'wetrainbayarea.org',
  'wh4f.org', 'whyspam.me', 'willselfdestruct.com', 'wuzup.net',
  'wuzupmail.net', 'yeah.net', 'yopmail.com', 'yopmail.net',
  'yopmail.org', 'ypmail.webarnak.fr.eu.org', 'cool.fr.nf', 'jetable.fr.nf',
  'nospam.ze.tc', 'nomail.xl.cx', 'mega.zik.dj', 'speed.1s.fr',
  'courriel.fr.nf', 'moncourrier.fr.nf', 'monemail.fr.nf', 'monmail.fr.nf',
  'gm.com', 'gmai.com', 'gmail.co', 'gmail.cm', 'gmial.com', 'gmaiil.com'
]);

// Check if domain is a known spam domain
function isSpamDomain(domain) {
  return SPAM_DOMAINS.has(domain.toLowerCase());
}

// Suspicious behavior detection
function detectSuspiciousBehavior(body, clientIP, userAgent) {
  const suspiciousPatterns = [
    // Very short messages (often spam)
    body.message.length < 20,
    
    // Suspicious user agent patterns
    /bot|crawler|spider|scraper|automated|headless/i.test(userAgent || ''),
    
    // Generic email patterns
    /^[a-z]+\d+@/.test(body.email),
    
    // Generic names
    /^(test|user|admin|support|info|contact|guest|visitor)$/i.test(body.name),
    
    // Suspicious domain patterns
    /\.tk$|\.ml$|\.ga$|\.cf$/.test(body.email.split('@')[1] || ''),
    
    // Rapid submission patterns (would need timing data)
    // This would be enhanced with actual timing data
    
    // Suspicious punctuation patterns
    /[!]{3,}|[?]{3,}|[.]{3,}/.test(body.message),
    
    // All caps messages
    body.message === body.message.toUpperCase() && body.message.length > 10,
    
    // Repeated characters
    /(.)\1{4,}/.test(body.message),
    
    // Suspicious URL patterns
    /https?:\/\/[^\s]+/.test(body.message),
    
    // Phone number patterns
    /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/.test(body.message),
  ];
  
  const suspiciousCount = suspiciousPatterns.filter(Boolean).length;
  
  return {
    isSuspicious: suspiciousCount >= 2,
    suspiciousPatterns: suspiciousPatterns.filter(Boolean),
    score: suspiciousCount,
    reasons: [
      ...suspiciousPatterns.filter(Boolean).map((pattern, index) => {
        const reasons = [
          'short_message', 'bot_user_agent', 'generic_email', 'generic_name',
          'suspicious_domain', 'rapid_submission', 'excessive_punctuation',
          'all_caps', 'repeated_chars', 'suspicious_url', 'phone_number'
        ];
        return reasons[index];
      })
    ]
  };
}

// Content-based spam detection
function detectSpamContent(message, name, email) {
  const spamPatterns = [
    // Common spam keywords
    /\b(viagra|cialis|casino|poker|lottery|winner|congratulations|free money|click here|act now|limited time|urgent|guaranteed|no risk)\b/i,
    
    // Excessive promotional language
    /\b(amazing|incredible|unbelievable|shocking|secret|exclusive|revolutionary)\b.*\b(discover|revealed|exposed|leaked)\b/i,
    
    // Suspicious URLs
    /https?:\/\/[^\s]+/g,
    
    // Excessive capitalization
    /[A-Z]{5,}/,
    
    // Repeated characters
    /(.)\1{4,}/,
    
    // Phone number patterns (often spam)
    /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/,
    
    // Common spam phrases
    /\b(work from home|make money|earn cash|get rich|investment opportunity|bitcoin|cryptocurrency|forex|trading)\b/i,
    
    // Suspicious punctuation patterns
    /[!]{3,}|[?]{3,}|[.]{3,}/,
    
    // Excessive exclamation marks
    /!{2,}/,
  ];
  
  const text = `${message} ${name} ${email}`.toLowerCase();
  
  // Calculate spam score
  const spamScore = spamPatterns.reduce((score, pattern) => {
    const matches = text.match(pattern);
    return score + (matches ? matches.length : 0);
  }, 0);
  
  // Additional checks
  const additionalChecks = [
    // Very short messages (often spam)
    message.length < 20,
    
    // Excessive special characters
    (message.match(/[!@#$%^&*()_+={}[\]|\\:";'<>?,./]/g) || []).length > 10,
    
    // All caps messages
    message === message.toUpperCase() && message.length > 10,
    
    // Repeated words
    /\b(\w+)\b.*\b\1\b.*\b\1\b/i.test(message),
  ];
  
  const additionalScore = additionalChecks.filter(Boolean).length;
  const totalScore = spamScore + additionalScore;
  
  return {
    isSpam: totalScore >= 3,
    score: totalScore,
    spamPatterns: spamPatterns.filter(pattern => pattern.test(text)),
    additionalChecks: additionalChecks.filter(Boolean),
    reasons: [
      ...spamPatterns.filter(pattern => pattern.test(text)).map(pattern => 'spam_keyword'),
      ...additionalChecks.filter(Boolean).map(() => 'suspicious_content')
    ]
  };
}

// Validate email format with enhanced validation
function isValidEmail(email) {
  // RFC 5322 compliant regex (simplified but more robust)
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  if (!emailRegex.test(email)) return false;
  
  // Additional validation checks
  const parts = email.split('@');
  if (parts.length !== 2) return false;
  
  const [local, domain] = parts;
  
  // Local part validation
  if (local.length > 64) return false;
  if (local.startsWith('.') || local.endsWith('.')) return false;
  if (local.includes('..')) return false;
  
  // Domain validation
  if (domain.length > 253) return false;
  if (domain.startsWith('.') || domain.endsWith('.')) return false;
  if (domain.includes('..')) return false;
  
  // Check for valid TLD
  const domainParts = domain.split('.');
  if (domainParts.length < 2) return false;
  const tld = domainParts[domainParts.length - 1];
  if (tld.length < 2) return false;
  
  // Check for spam domains
  if (isSpamDomain(domain)) return false;
  
  // Check for common invalid patterns
  const invalidPatterns = [
    /\.{2,}/,           // Multiple consecutive dots
    /@.*@/,             // Multiple @ symbols
    /\.@/,               // Dot before @
    /@\./,               // Dot after @
    /^@/,                // Starts with @
    /@$/,                // Ends with @
    /\s/,                // Contains spaces
    /[<>]/,              // Contains angle brackets
  ];
  
  return !invalidPatterns.some(pattern => pattern.test(email));
}

// Advanced input validation with character pattern analysis
function enhancedInputValidation(data) {
  const errors = {};
  
  // Enhanced name validation
  if (!data.name || typeof data.name !== 'string') {
    errors.name = 'Name is required';
  } else {
    const name = data.name.trim();
    if (name.length < 2 || name.length > 100) {
      errors.name = 'Name must be between 2 and 100 characters';
    } else if (!/^[a-zA-Z\s\-'\.]+$/.test(name)) {
      errors.name = 'Name contains invalid characters';
    } else if (name.split(' ').length > 5) {
      errors.name = 'Name appears to be too long';
    } else if (name.split(' ').length < 1) {
      errors.name = 'Please provide a valid name';
    } else if (/(.)\1{3,}/.test(name)) {
      errors.name = 'Name contains repeated characters';
    }
  }
  
  // Enhanced email validation (already handled by isValidEmail, but add additional checks)
  if (!data.email || typeof data.email !== 'string') {
    errors.email = 'Email is required';
  } else {
    const email = data.email.trim();
    if (email.length > 254) {
      errors.email = 'Email address is too long';
    } else if (email.includes('..')) {
      errors.email = 'Email contains invalid characters';
    } else if (email.startsWith('.') || email.endsWith('.')) {
      errors.email = 'Email format is invalid';
    }
  }
  
  // Enhanced message validation
  if (!data.message || typeof data.message !== 'string') {
    errors.message = 'Message is required';
  } else {
    const message = data.message.trim();
    if (message.length < 10 || message.length > 1000) {
      errors.message = 'Message must be between 10 and 1000 characters';
    } else if (message.split(' ').length < 3) {
      errors.message = 'Message appears to be too short';
    } else if (message.split('\n').length > 20) {
      errors.message = 'Message has too many line breaks';
    } else if (/(.)\1{5,}/.test(message)) {
      errors.message = 'Message contains excessive repeated characters';
    } else if (message.match(/[!@#$%^&*()_+={}[\]|\\:";'<>?,./]/g)?.length > 20) {
      errors.message = 'Message contains too many special characters';
    } else if (message === message.toUpperCase() && message.length > 20) {
      errors.message = 'Please avoid using all capital letters';
    }
  }
  
  return { isValid: Object.keys(errors).length === 0, errors };
}

// Server-side validation with spam detection
function validateFormData(data) {
  // Use enhanced input validation first
  const enhancedValidation = enhancedInputValidation(data);
  if (!enhancedValidation.isValid) {
    return enhancedValidation;
  }
  
  const errors = {};
  
  // Validate email format and spam domains
  const email = data.email.trim();
  if (!isValidEmail(email)) {
    const domain = email.split('@')[1];
    if (domain && isSpamDomain(domain)) {
      errors.email = 'Disposable email addresses are not allowed';
    } else {
      errors.email = 'Please enter a valid email address';
    }
  }
  
  // Check for spam content if all basic validation passes
  if (Object.keys(errors).length === 0) {
    const spamDetection = detectSpamContent(data.message, data.name, data.email);
    if (spamDetection.isSpam) {
      errors.message = 'Message appears to be spam. Please provide a legitimate message.';
      errors._spamDetected = true;
      errors._spamScore = spamDetection.score;
      errors._spamReasons = spamDetection.reasons;
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
}

// Enhanced validation with suspicious behavior detection
function validateFormDataWithBehavior(data, clientIP, userAgent) {
  const basicValidation = validateFormData(data);
  
  if (!basicValidation.isValid) {
    return basicValidation;
  }
  
  // Check for suspicious behavior
  const behaviorDetection = detectSuspiciousBehavior(data, clientIP, userAgent);
  if (behaviorDetection.isSuspicious) {
    return {
      isValid: false,
      errors: {
        message: 'Submission appears to be automated or suspicious. Please provide a legitimate message.',
        _suspiciousDetected: true,
        _suspiciousScore: behaviorDetection.score,
        _suspiciousReasons: behaviorDetection.reasons
      }
    };
  }
  
  return basicValidation;
}

// Vercel Serverless Function handler
export default async function handler(req, res) {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', corsHeaders['Access-Control-Allow-Origin']);
    res.setHeader('Access-Control-Allow-Methods', corsHeaders['Access-Control-Allow-Methods']);
    res.setHeader('Access-Control-Allow-Headers', corsHeaders['Access-Control-Allow-Headers']);
    res.setHeader('Access-Control-Max-Age', corsHeaders['Access-Control-Max-Age']);
    return res.status(200).end();
  }

  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      message: 'Method not allowed' 
    });
  }

  // Convert Express request to Astro-style format
  const astroRequest = {
    headers: {
      get: (name) => req.headers[name] || req.headers[name.toLowerCase()]
    },
    json: async () => req.body
  };

  // Call the Astro handler
  const result = await handlePost(astroRequest);
  
  // Return the result with CORS headers
  return res.status(result.status).json(result.body);
}

// Astro-style handler (internal)
async function handlePost({ request }) {
  try {
    // Get client IP address for rate limiting
    const clientIP = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown';

    // Check enhanced rate limit
    const rateLimitResult = checkEnhancedRateLimit(clientIP);
    if (!rateLimitResult.allowed) {
      // Log rate limiting events
      logSecurityEvent('rate_limited', {
        level: rateLimitResult.level,
        reason: rateLimitResult.reason,
        retryAfter: rateLimitResult.retryAfter
      }, clientIP);
      
      return new Response(JSON.stringify({
        success: false,
        message: rateLimitResult.reason,
        retryAfter: rateLimitResult.retryAfter
      }), {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          'Retry-After': rateLimitResult.retryAfter.toString(),
          ...corsHeaders
        }
      });
    }

    // Parse JSON request body
    const body = await request.json();

    // Get user agent for suspicious behavior detection
    const userAgent = request.headers.get('user-agent') || '';

    // Honeypot validation - reject if website field has any value
    if (body.website && body.website.trim() !== '') {
      logSecurityEvent('honeypot_triggered', {
        website: body.website,
        userAgent
      }, clientIP);
      
      return new Response(JSON.stringify({
        success: false,
        message: 'Invalid submission'
      }), {
        status: 400,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      });
    }

    // Enhanced validation with suspicious behavior detection
    const validation = validateFormDataWithBehavior(body, clientIP, userAgent);
    if (!validation.isValid) {
      // Log spam and suspicious behavior events using centralized logging
      if (validation.errors._spamDetected) {
        logSecurityEvent('spam_detected', {
          email: body.email,
          spamScore: validation.errors._spamScore,
          spamReasons: validation.errors._spamReasons,
          message: body.message.substring(0, 100) + '...',
          userAgent
        }, clientIP);
      }
      
      if (validation.errors._suspiciousDetected) {
        logSecurityEvent('suspicious_behavior', {
          email: body.email,
          suspiciousScore: validation.errors._suspiciousScore,
          suspiciousReasons: validation.errors._suspiciousReasons,
          message: body.message.substring(0, 100) + '...',
          userAgent
        }, clientIP);
      }
      
      return new Response(JSON.stringify({
        success: false,
        message: 'Please check your input',
        errors: validation.errors
      }), {
        status: 400,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      });
    }

    // Sanitize all inputs
    const sanitizedData = {
      name: sanitizeInput(body.name),
      email: sanitizeInput(body.email),
      message: sanitizeInput(body.message)
    };

    // Send email using Resend
    try {
      const emailData = await resend.emails.send({
        from: 'Contact Form <onboarding@resend.dev>',
        to: process.env.TO_EMAIL,
        replyTo: sanitizedData.email,
        subject: `New Contact Form Submission from ${sanitizedData.name}`,
        html: `
          <h2>New Contact Form Submission</h2>
          <p><strong>From:</strong> ${sanitizedData.name}</p>
          <p><strong>Email:</strong> ${sanitizedData.email}</p>
          <p><strong>Message:</strong></p>
          <p>${sanitizedData.message}</p>
        `
      });

      console.log('Email sent successfully:', emailData.id);

      // Log successful submission
      logSecurityEvent('submission_success', {
        email: sanitizedData.email,
        name: sanitizedData.name,
        messageLength: sanitizedData.message.length,
        userAgent
      }, clientIP);

      return new Response(JSON.stringify({
        success: true,
        message: 'Message sent successfully!'
      }), {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      });

    } catch (emailError) {
      console.error('Failed to send email:', emailError);
      return new Response(JSON.stringify({
        success: false,
        message: 'Failed to send message. Please try again.'
      }), {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders
        }
      });
    }

  } catch (error) {
    console.error('Server error:', error);
    return new Response(JSON.stringify({
      success: false,
      message: 'Failed to send message. Please try again.'
    }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json',
        ...corsHeaders
      }
    });
  }
}
